<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS高程读书笔记-第三章基本概念 | 🌵BangKk</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="book-javascript-3-3

3. 基本概念

3.1 语法

区分大小写
标识符：变量、函数、属性的名字。
   第一个字符必须是字母、下划线（\_）或美元符（\$）
   其他字符可以是字母、下划线、美元符号或数字
 ...">
    <link rel="preload" href="/blog/assets/css/0.styles.d74d041f.css" as="style"><link rel="preload" href="/blog/assets/js/app.09de7167.js" as="script"><link rel="preload" href="/blog/assets/js/7.81338775.js" as="script"><link rel="preload" href="/blog/assets/js/3.91e53e24.js" as="script"><link rel="preload" href="/blog/assets/js/10.a2a5e182.js" as="script"><link rel="prefetch" href="/blog/assets/js/11.3ab1a395.js"><link rel="prefetch" href="/blog/assets/js/12.0244b2aa.js"><link rel="prefetch" href="/blog/assets/js/13.a04fab3e.js"><link rel="prefetch" href="/blog/assets/js/14.62e0c4f5.js"><link rel="prefetch" href="/blog/assets/js/4.9bc8ba7a.js"><link rel="prefetch" href="/blog/assets/js/5.6a012675.js"><link rel="prefetch" href="/blog/assets/js/6.b6c974ac.js"><link rel="prefetch" href="/blog/assets/js/8.1b93f0c8.js"><link rel="prefetch" href="/blog/assets/js/9.3e091b61.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.0a926223.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d74d041f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">🌵BangKk </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">博客</a></li><li class="nav-item"><a href="/blog/tag/" class="nav-link">标签</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">🌵BangKk </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">博客</a></li><li class="mobile-nav-item"><a href="/blog/tag/" class="nav-link">标签</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        JS高程读书笔记-第三章基本概念
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">BangKk</span> <span itemprop="address">   in Chengdu</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-07-18T00:00:00.000Z">
      2020-07-18
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/blog/tag/读书笔记" data-v-d832e844> 读书笔记 </a></li><li class="post-tag" data-v-d832e844><a href="/blog/tag/JavaScript 高级程序设计" data-v-d832e844> JavaScript 高级程序设计 </a></li><li class="post-tag" data-v-d832e844><a href="/blog/tag/JS 基本概念" data-v-d832e844> JS 基本概念 </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p><img src="/blog/assets/img/book-javascript-3-3.b73de821.jpg" alt="book-javascript-3-3"></p> <h2 id="_3-基本概念"><a href="#_3-基本概念" class="header-anchor">#</a> 3. 基本概念</h2> <h3 id="_3-1-语法"><a href="#_3-1-语法" class="header-anchor">#</a> 3.1 语法</h3> <ol><li>区分大小写</li> <li>标识符：变量、函数、属性的名字。
<ol><li>第一个字符必须是字母、下划线（_）或美元符（$）</li> <li>其他字符可以是字母、下划线、美元符号或数字</li> <li>ECMAScript 标准中的标识符采用驼峰大小写格式</li></ol></li> <li>注释</li> <li>严格模式（ES5 引入）
<ol><li>它是一个编译指示(pragma)，告诉支持的 JavaScript 引擎切换到严格模式，这是为不破坏 ECMAScript 3 语法而特意选定的语法</li></ol></li> <li>语句
<ol><li>分号结尾，如果省略，则由解析器确定语句的结尾</li> <li>分号结尾能增进代码的性能，因为解析器不用花时间推测在哪里插入分号了</li></ol></li></ol> <h3 id="_3-2-关键字和保留字"><a href="#_3-2-关键字和保留字" class="header-anchor">#</a> 3.2 关键字和保留字</h3> <p>关键字：这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等</p> <p>保留字：有可能在将来被用作关键字</p> <blockquote><p>注意：标识符不应该使用关键字或保留字</p></blockquote> <h3 id="_3-4-数据类型"><a href="#_3-4-数据类型" class="header-anchor">#</a> 3.4 数据类型</h3> <p>基本类型</p> <ol><li>undefined</li> <li>null</li> <li>boolean</li> <li>string</li> <li>number</li> <li>sysbol</li></ol> <p>复杂类型</p> <ol><li>object</li></ol> <p>ES 中所有值最终都将是上述 6 种数据类型之一</p> <h4 id="_3-4-1-typeof-操作符"><a href="#_3-4-1-typeof-操作符" class="header-anchor">#</a> 3.4.1 typeof 操作符</h4> <p>返回值</p> <ol><li>undefined ---- 如果值未定义</li> <li>boolean ---- 如果值为布尔值</li> <li>string ---- 如果这个值是字符串</li> <li>number ---- 如果这个值是数值</li> <li>object ---- 如果值为对象或 null</li> <li>function ---- 如果这个值是函数</li></ol> <h4 id="undefined-类型"><a href="#undefined-类型" class="header-anchor">#</a> Undefined 类型</h4> <p>在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined</p> <blockquote><p>注意：在代码中访问一个未声明的变量会报 ReferenceError，而对未声明变量执行 typeof 会返回 undefined</p></blockquote> <h4 id="null-类型"><a href="#null-类型" class="header-anchor">#</a> Null 类型</h4> <p>从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回&quot;object&quot;的原因</p> <p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用</p> <h4 id="boolean-类型"><a href="#boolean-类型" class="header-anchor">#</a> Boolean 类型</h4> <p>对任何数据类型的值调用 Boolean()函数，而且总会返回一个 Boolean 值，至于返回的 这个值是 true 还是 false，取决于要转换值的数据类型及其实际值。</p> <table><thead><tr><th>数据类型</th> <th>转换为 true 的值</th> <th>转换为 false 的值</th></tr></thead> <tbody><tr><td>Boolean</td> <td>true</td> <td>false</td></tr> <tr><td>String</td> <td>任何非空字符串</td> <td>&quot;&quot;(空字符串)</td></tr> <tr><td>Number</td> <td>任何非零数字值(包括无穷大)</td> <td>0 和 NaN</td></tr> <tr><td>Object</td> <td>任何对象</td> <td>null</td></tr> <tr><td>Undefined</td> <td>不适用</td> <td>undefined</td></tr></tbody></table> <h4 id="number-类型"><a href="#number-类型" class="header-anchor">#</a> Number 类型</h4> <p>使用 IEEE754 格式来表示整数和浮点数值</p> <h5 id="整数"><a href="#整数" class="header-anchor">#</a> 整数</h5> <ol><li>十进制</li> <li>十六进制：前导<code>0x</code>，后面跟 0 - 9 或 A - F</li> <li>八进制：前导<code>0</code>，后面跟 0 - 7</li></ol> <blockquote><p>注意：八进制在严格模式下无效，且第一位必须是 0，如果字面值中由超过了 7，则前导零会被忽略，当作十进制解析</p></blockquote> <p>在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。</p> <h5 id="浮点数"><a href="#浮点数" class="header-anchor">#</a> 浮点数</h5> <p>保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 转换为整数值。</p> <h5 id="数值范围"><a href="#数值范围" class="header-anchor">#</a> 数值范围</h5> <p>ECMAScript 中能表示的最大值和最小值：</p> <ol><li>Number.MAX_VALUE</li> <li>Number.MIN_VALUE</li></ol> <p>计算：</p> <ol><li>超出范围则转换成 Infinity 或 -Infinity。</li> <li>正数除以 0 返回 Infinity</li> <li>负数除以 0 返回-Infinity</li></ol> <p>如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算， 因为 Infinity 不是能够参与计算的数值，如下例子所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">+</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isFinite</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><h5 id="nan"><a href="#nan" class="header-anchor">#</a> NaN</h5> <p>NaN，即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数
未返回数值的情况(这样就不会抛出错误了)。</p> <p>计算：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false(10 是一个数值)</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false(可以被转换成数值 10)</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">&quot;blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true(不能转换成数值)</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false(可以被转换成数值 1)</span>
</code></pre></div><p>计算过程：判断值被 Number 调用后的返回值是否不是一个数值</p> <blockquote><p>注意：0 除以 0 会返回 NaN</p></blockquote> <h5 id="数值转换"><a href="#数值转换" class="header-anchor">#</a> 数值转换</h5> <ol><li>Number()：适用任何类型</li> <li>parseInt()：适用字符串转数值</li> <li>parseFloat()：适用字符串转数值</li></ol> <p>Number()函数的转换规则如下：</p> <ol><li>如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</li> <li>如果是数字值，只是简单的传入和返回。</li> <li>如果是 null 值，返回 0。</li> <li>如果是 undefined，返回 NaN。</li> <li>如果是字符串，遵循下列规则:
<ol><li>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即&quot;1&quot; 会变成 1，&quot;123&quot;会变成 123，而&quot;011&quot;会变成 11(注意:前导的零被忽略了);</li> <li>如果字符串中包含有效的浮点格式，如&quot;1.1&quot;，则将其转换为对应的浮点数值(同样，也会忽 略前导零);</li> <li>如果字符串中包含有效的十六进制格式，例如&quot;0xf&quot;，则将其转换为相同大小的十进制整 数值;</li> <li>如果字符串是空的(不包含任何字符)，则将其转换为 0;</li> <li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li></ol></li> <li>如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换
的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符
串值。</li></ol> <p>由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()函数。</p> <p>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN;也就是说，用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如 果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。例如，&quot;1234blue&quot;会被转换为 1234，因为&quot;blue&quot;会被完全忽略。类似地，&quot;22.5&quot; 4 会被转换为 22，因为小数点并不是有效的数字字符。</p> <p>下面是一些例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;1234blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1234</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0xA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10(十六进制数)</span>
<span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">22.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 22</span>
<span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;070&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 56(八进制数)</span>
<span class="token keyword">var</span> num6 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;70&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 70(十进制数)</span>
<span class="token keyword">var</span> num7 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0xf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15(十六进制数)</span>
</code></pre></div><p>指定基数会影响到转换的输出结果。例如:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2 (按二进制解析)</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//8 (按八进制解析)</span>
<span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10(按十进制解析)</span>
<span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//16(按十六进制解析)</span>
</code></pre></div><blockquote><p>注意：不指定基数意味着让 parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，建议无论在什么情况下都明确指定基数。</p></blockquote> <p>与 parseInt()函数类似，parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说， &quot;22.34.5&quot;将会被转换为 22.34。
除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点，或者小数点后 都是零)，parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;1234blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1234 (整数)</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;0xA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
<span class="token keyword">var</span> num3 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;22.5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 22.5</span>
<span class="token keyword">var</span> num4 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;22.34.5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 22.34</span>
<span class="token keyword">var</span> num5 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;0908.5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 908.5</span>
<span class="token keyword">var</span> num6 <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;3.125e7&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 31250000</span>
</code></pre></div><h4 id="string-类型"><a href="#string-类型" class="header-anchor">#</a> String 类型</h4> <p>特殊的字符字面量：</p> <table><thead><tr><th>字面量</th> <th>含义</th></tr></thead> <tbody><tr><td>\n</td> <td>换行</td></tr> <tr><td>\t</td> <td>制表</td></tr> <tr><td>\b</td> <td>空格</td></tr> <tr><td>\r</td> <td>回车</td></tr> <tr><td>\f</td> <td>进纸</td></tr> <tr><td>\</td> <td>斜杠</td></tr> <tr><td>\'</td> <td>单引号(')，在用单引号表示的字符串中使用。例如:'He said, 'hey.''</td></tr> <tr><td>\&quot;</td> <td>双引号(&quot;)，在用双引号表示的字符串中使用。例如:&quot;He said, &quot;hey.&quot;&quot;</td></tr> <tr><td>\xnn</td> <td>以十六进制代码 nn 表示的一个字符(其中 n 为 0~F)。例如，\x41 表示&quot;A&quot;</td></tr> <tr><td>\unnnn</td> <td>以十六进制代码 nnnn 表示的一个 Unicode 字符(其中 n 为 0~F)。例如，\u03a3 表示希腊字符 Σ</td></tr></tbody></table> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> text <span class="token operator">=</span> <span class="token string">&quot;This is the letter sigma: \u03a3.&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子中的变量 text 有 28 个字符，其中 6 个字符长的转义序列表示 1 个字符。</p> <blockquote><p>注意：如果字符串中包含双字节字符，那么 length 属性 可能不会精确地返回字符串中的字符数目。</p></blockquote> <p>转换成字符串：</p> <ol><li>toString()：几乎每个值都有这个方法</li> <li>String()</li></ol> <p>String() 规则：</p> <ol><li>如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果;</li> <li>如果值是 null，则返回&quot;null&quot;;</li> <li>如果值是 undefined，则返回&quot;undefined&quot;。</li></ol> <blockquote><p>注意：null 和 undefined 没有 toString() 方法。</p></blockquote> <h4 id="object-类型"><a href="#object-类型" class="header-anchor">#</a> Object 类型</h4> <p>Object 的每个实例都有下列属性和方法：</p> <ol><li><code>constructor</code>: 保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 就是 Object()。</li> <li><code>hasOwnProperty(propertyName)</code>: 用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例如: o.hasOwnProperty(&quot;name&quot;))。</li> <li><code>isPrototypeOf(object)</code>: 用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原 型)。</li> <li><code>propertyIsEnumerable(propertyName)</code>: 用于检查给定的属性是否能够使用 for-in 语句 (本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符
串形式指定。</li> <li><code>toLocaleString()</code>: 返回对象的字符串表示，该字符串与执行环境的地区对应。</li> <li><code>toString()</code>: 返回对象的字符串表示。</li> <li><code>valueOf()</code>: 返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值
相同。</li></ol> <blockquote><p>注意： 从技术角度讲，ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。 浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是 由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也 可能不会继承 Object。</p></blockquote> <h3 id="_3-5-操作符"><a href="#_3-5-操作符" class="header-anchor">#</a> 3.5 操作符</h3> <p>ECMA-262 描述了一组用于操作数据值的操作符，包括：</p> <ol><li>算术操作符(如加号和减号)</li> <li>位操作符</li> <li>关系操作符</li> <li>相等操作符</li></ol> <p>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。<strong>不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf() 和(或)toString()方法，以便取得可以操作的值。</strong></p> <h4 id="一元操作符"><a href="#一元操作符" class="header-anchor">#</a> 一元操作符</h4> <ul><li>递增和递减操作符(++, --)</li></ul> <p>在应用于不同的值时，递增和递减操作符遵循下列规则。</p> <ol><li>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字 符串变量变成数值变量。</li> <li>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN(第 4 章将详细讨论)。 字符串变量变成数值变量。</li> <li>在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。</li> <li>在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。</li> <li>在应用于浮点数值时，执行加减 1 的操作。</li> <li>在应用于对象时，先调用对象的 valueOf()方法(第 5 章将详细讨论)以取得一个可供操作的
值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span> s1<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token string">&quot;z&quot;</span><span class="token punctuation">;</span> s2<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> b<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span> f<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 0.10000000000000009</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
o<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// -2</span>
</code></pre></div><ul><li>一元加和减操作符(+, -)</li></ul> <p>对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换。 换句话说，布尔值 false 和 true 将被转换为 0 和 1，字符串值会被按照一组特殊的规则进行解析，而 对象是先调用它们的 valueOf()和(或)toString()方法，再转换得到的值。</p> <h4 id="位操作符"><a href="#位操作符" class="header-anchor">#</a> 位操作符</h4> <p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数 值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值。而是先将 64 位的值转换成 32 位 的整数，然后执行操作，最后再将结果转换回 64 位。对于开发人员来说，由于 64 位存储格式是透明的， 因此整个过程就像是只存在 32 位的整数一样。</p> <p>对于有符号的整数，32 位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号:0 表示正 数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。其中，正数以 纯二进制格式存储，31 位中的每一位都表示 2 的幂。</p> <p>负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下 列 3 个步骤:</p> <p>(1) 求这个数值绝对值的二进制码(例如，要求18 的二进制补码，先求 18 的二进制码);
(2) 求二进制反码，即将 0 替换为 1，将 1 替换为 0;
(3) 得到的二进制反码加 1。</p> <p>在 ECMAScript 中，当对数值应用位操作符时，后台会发生如下转换过程:64 位的数值被转换成 32 位数值，然后执行位操作，最后再将 32 位的结果转换回 64 位数值。</p> <p>位操作符：</p> <ol><li>按位非（NOT），符号：<code>～</code></li> <li>按位与（AND），符号：<code>&amp;</code></li> <li>按位或（OR），符号：<code>｜</code></li> <li>按位异或（XOR），符号 <code>^</code></li> <li>左移，符号 <code>&lt;&lt;</code>，右侧填充<code>0</code></li> <li>有符号位右移，号 <code>&gt;&gt;</code>，左侧补<code>0</code>，保留符号位</li> <li>无符号位右移，号 <code>&gt;&gt;&gt;</code>，左侧补<code>0</code>，32位整体右移，对正数来说与有符号位右移一样。</li></ol> <h4 id="布尔操作符"><a href="#布尔操作符" class="header-anchor">#</a> 布尔操作符</h4> <ol><li>逻辑非</li></ol> <p>符号：<code>!</code></p> <p>操作数：1个，例 <code>!a</code></p> <p>规则：</p> <ul><li>如果操作数是一个对象，返回 false;</li> <li>如果操作数是一个空字符串，返回 true;</li> <li>如果操作数是一个非空字符串，返回 false;</li> <li>如果操作数是数值 0，返回 true;</li> <li>如果操作数是任意非 0 数值(包括 Infinity)，返回 false;</li> <li>如果操作数是 null，返回 true;</li> <li>如果操作数是 NaN，返回 true;</li> <li>如果操作数是 undefined，返回 true。</li></ul> <p>逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际 上就会模拟 Boolean()转型函数的行为。其中，第一个逻辑非操作会基于无论什么操作数返回一个布 尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值。当然，最终结 果与对这个值使用 Boolean()函数相同。</p> <ol start="2"><li>逻辑与</li></ol> <p>符号：<code>&amp;&amp;</code></p> <p>操作数：2个，例 <code>a &amp;&amp; b</code></p> <p>规则：</p> <ul><li>如果第一个操作数是对象，则返回第二个操作数;</li> <li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;</li> <li>如果两个操作数都是对象，则返回第二个操作数;</li> <li>如果有一个操作数是 null，则返回 null;</li> <li>如果有一个操作数是 NaN，则返回 NaN;</li> <li>如果有一个操作数是 undefined，则返回 undefined。</li></ul> <p>逻辑与属于短路操作符，即第一个操作数如果为 false，则不会进行第二个操作数的求值了。</p> <ol><li>逻辑或</li></ol> <p>符号：<code>||</code></p> <p>操作数：2个，例 <code>a || b</code></p> <p>规则：</p> <ul><li>如果第一个操作数是对象，则返回第一个操作数;</li> <li>如果第一个操作数的求值结果为 false，则返回第二个操作数;</li> <li>如果两个操作数都是对象，则返回第一个操作数;</li> <li>如果两个操作数都是 null，则返回 null;</li> <li>如果两个操作数都是 NaN，则返回 NaN;</li> <li>如果两个操作数都是 undefined，则返回 undefined。</li></ul> <p>逻辑或也属于短路操作符，即第一个操作数如果为 true，则不会进行第二个操作数的求值了。</p> <h4 id="乘性操作符"><a href="#乘性操作符" class="header-anchor">#</a> 乘性操作符</h4> <p>ECMAScript 定义了 3 个乘性操作符:乘法、除法和求模。</p> <p>在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某 个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值。也就是说，空字符串将被当作 0，布尔值 true 将被当作 1。</p> <ol><li>乘法</li></ol> <p>符号：<code>*</code></p> <p>规则：</p> <ul><li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了 ECMAScript 数值的表示范围，
则返回 Infinity 或-Infinity;</li> <li>如果有一个操作数是 NaN，则结果是 NaN;</li> <li>如果是 Infinity 与 0 相乘，则结果是 NaN;</li> <li>如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数
的符号;</li> <li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity;</li> <li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul> <ol start="2"><li>除法</li></ol> <p>符号：<code>/</code></p> <p>规则：</p> <ul><li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而
如果只有一个操作数有符号，那么结果就是负数。如果商超过了 ECMAScript 数值的表示范围，
则返回 Infinity 或-Infinity;</li> <li>如果有一个操作数是 NaN，则结果是 NaN;</li> <li>如果是 Infinity 被 Infinity 除，则结果是 NaN;</li> <li>如果是零被零除，则结果是 NaN;</li> <li>如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号;</li> <li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号;</li> <li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul> <ol start="3"><li>求模</li></ol> <p>符号：<code>%</code></p> <ul><li>如果操作数都是数值，执行常规的除法计算，返回除得的余数;</li> <li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;</li> <li>如果被除数是有限大的数值而除数是零，则结果是 NaN;</li> <li>如果是 Infinity 被 Infinity 除，则结果是 NaN;</li> <li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;</li> <li>如果被除数是零，则结果是零;</li> <li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul> <h4 id="加性操作符"><a href="#加性操作符" class="header-anchor">#</a> 加性操作符</h4> <ol><li>加法</li></ol> <p>符号：<code>+</code></p> <p>规则：</p> <ul><li>如果有一个操作数是 NaN，则结果是 NaN;</li> <li>如果是 Infinity 加 Infinity，则结果是 Infinity;</li> <li>如果是-Infinity 加-Infinity，则结果是-Infinity;</li> <li>如果是 Infinity 加-Infinity，则结果是 NaN;</li> <li>如果是+0 加+0，则结果是+0;</li> <li>如果是-0 加-0，则结果是0;</li> <li>如果是+0 加-0，则结果是+0。
不过，如果有一个操作数是字符串，那么就要应用如下规则:</li> <li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;</li> <li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接
起来。</li> <li>如果有一个操作数是对象、数值或布尔值，则调用它们的 toString()方法取得相应的字符串值，
然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串&quot;undefined&quot;和&quot;null&quot;。</li></ul> <ol start="2"><li>减法</li></ol> <p>符号：<code>-</code></p> <p>规则：</p> <ul><li>如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;</li> <li>如果有一个操作数是 NaN，则结果是 NaN;</li> <li>如果是 Infinity 减 Infinity，则结果是 NaN;</li> <li>如果是-Infinity 减-Infinity，则结果是 NaN;</li> <li>如果是 Infinity 减-Infinity，则结果是 Infinity;</li> <li>如果是-Infinity 减 Infinity，则结果是-Infinity;</li> <li>如果是+0 减+0，则结果是+0;</li> <li>如果是+0 减-0，则结果是-0;</li> <li>如果是0 减0，则结果是+0;</li> <li>如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将
其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果
就是 NaN;</li> <li>如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到
的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()
方法并将得到的字符串转换为数值。</li></ul> <h4 id="关系操作符"><a href="#关系操作符" class="header-anchor">#</a> 关系操作符</h4> <ol><li>大于</li> <li>小于</li> <li>大于等于</li> <li>小于等于</li></ol> <p>规则：</p> <ul><li>如果两个操作数都是数值，则执行数值比较。</li> <li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li> <li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li> <li>如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执
行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面
的规则执行比较。</li> <li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li></ul> <p>在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人都会认为，在比较字符串值 时，小于的意思是“在字母表中的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际上完 全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经 过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因 此我们就会看到如下所示的奇怪现象:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;Brick&quot;</span> <span class="token operator">&lt;</span> <span class="token string">&quot;alphabet&quot;</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token comment">// B 的字符编码为 66，而 a 的字符编码是 97</span>

<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;23&quot;</span> <span class="token operator">&lt;</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// &quot;2&quot;的字符编码是 50，而&quot;3&quot;的字符编码是 51</span>

<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;23&quot;</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// 字符串&quot;23&quot;会被转换成数值 23，然后再与 3 进行比较</span>

<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token comment">// 因为&quot;a&quot;被转换成了 NaN，任何操作数与 NaN 进行关系比较，结果都是 false</span>
<span class="token comment">// 所以</span>
<span class="token keyword">var</span> result1 <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token keyword">var</span> result2 <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><h4 id="相等操作符"><a href="#相等操作符" class="header-anchor">#</a> 相等操作符</h4> <p>最早的 ECMAScript 中的相等和不等 操作符会在执行比较之前，先将对象转换成相似的类型。后来，有人提出了这种转换到底是否合理的质疑。</p> <p>最后，ECMAScript 的解决方案就是提供两组操作符:相等和不相等——先转换再比较，全等和不 全等——仅比较而不转换。</p> <ol><li>相等和不相等</li></ol> <p>符号：<code>==</code> 和 <code>!=</code></p> <p>操作数：2个，先强制转型，然后再比较它们的相等性</p> <p>规则：</p> <ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1;</li> <li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值;</li> <li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类
型值按照前面的规则进行比较; 这两个操作符在进行比较时则要遵循下列规则。</li> <li>null 和 undefined 是相等的。</li> <li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li> <li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示:
即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。</li> <li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，
则相等操作符返回 true;否则，返回 false。</li></ul> <p>特殊情况的比较结果：</p> <table><thead><tr><th>表达式</th> <th>值</th></tr></thead> <tbody><tr><td>null == undefined</td> <td>true</td></tr> <tr><td>&quot;NaN&quot; == NaN</td> <td>false</td></tr> <tr><td>5 == NaN</td> <td>false</td></tr> <tr><td>NaN == NaN</td> <td>false</td></tr> <tr><td>NaN != NaN</td> <td>true</td></tr> <tr><td>false == 0</td> <td>true</td></tr> <tr><td>true == 1</td> <td>true</td></tr> <tr><td>true == 2</td> <td>false</td></tr> <tr><td>undefined == 0</td> <td>false</td></tr> <tr><td>null == 0</td> <td>false</td></tr> <tr><td>&quot;5&quot;==5</td> <td>true</td></tr></tbody></table> <ol start="2"><li>全等和不全等</li></ol> <p>符号：<code>===</code> 和 <code>!==</code></p> <p>规则：</p> <ol><li>不转换类型，直接进行比较</li></ol> <h4 id="条件操作符"><a href="#条件操作符" class="header-anchor">#</a> 条件操作符</h4> <p>即三目运算符，语法：</p> <div class="language-js extra-class"><pre class="language-js"><code>variable <span class="token operator">=</span> boolean_expression <span class="token operator">?</span> true_value <span class="token operator">:</span> false_value<span class="token punctuation">;</span>
</code></pre></div><h4 id="赋值操作符"><a href="#赋值操作符" class="header-anchor">#</a> 赋值操作符</h4> <p>符号：<code>=</code>，例 <code>a = b</code></p> <h4 id="逗号操作符"><a href="#逗号操作符" class="header-anchor">#</a> 逗号操作符</h4> <p>使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> num2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> num3<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><p>逗号操作符多用于声明多个变量;但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项，如下面的例子所示:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// num的值为0</span>
</code></pre></div><h3 id="_3-6-语句"><a href="#_3-6-语句" class="header-anchor">#</a> 3.6 语句</h3> <p>ECMA-262 规定了一组语句(也称为流控制语句)。从本质上看，语句定义了 ECMAScript 中的主要 语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出;也可以比 较复杂，例如指定重复执行某个命令的次数。</p> <h4 id="if-语句"><a href="#if-语句" class="header-anchor">#</a> if 语句</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> statement1 <span class="token keyword">else</span> statement2
</code></pre></div><p>其中的 condition(条件)可以是任意表达式;而且对这个表达式求值的结果不一定是布尔值。 ECMAScript 会自动调用 Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对 condition 求值的结果是 true，则执行 statement1(语句 1)，如果对 condition 求值的结果是 false，则执行 statement2(语句 2)。而且这两个语句既可以是一行代码，也可以是一个代码块(以一对花括号括起来的多行代码)。</p> <h4 id="do-while-语句"><a href="#do-while-语句" class="header-anchor">#</a> do while 语句</h4> <p>do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。以下是 do-while 语句的示例:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">do</span> <span class="token punctuation">{</span>
  i <span class="token operator">+=</span> <span class="token number">2</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="while-语句"><a href="#while-语句" class="header-anchor">#</a> while 语句</h4> <p>while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="for-语句"><a href="#for-语句" class="header-anchor">#</a> for 语句</h4> <p>for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代
码的能力。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">alert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><h4 id="for-in-语句"><a href="#for-in-语句" class="header-anchor">#</a> for-in 语句</h4> <p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> propName <span class="token keyword">in</span> window<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意：ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。 具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p></blockquote> <p>如果表示要迭代的对象的变量值为 null 或 undefined，for-in 语句会抛出错误。</p> <p>ECMAScript 5 更正了这一行为;对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。</p> <h4 id="label-语句"><a href="#label-语句" class="header-anchor">#</a> label 语句</h4> <p>使用 label 语句可以在代码中添加标签，以便将来使用。</p> <div class="language-js extra-class"><pre class="language-js"><code>start<span class="token operator">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子中定义的 start 标签可以在将来由 break 或 continue 语句引用。加标签的语句一般都
要与 for 语句等循环语句配合使用。</p> <h4 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="header-anchor">#</a> break 和 continue 语句</h4> <p>break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环， 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行。</p> <h4 id="with-语句"><a href="#with-语句" class="header-anchor">#</a> with 语句</h4> <p>with 语句的作用是将代码的作用域设置到一个特定的对象中。</p> <p>定义 with 语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> qs <span class="token operator">=</span> location<span class="token punctuation">.</span>search<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> hostName <span class="token operator">=</span> location<span class="token punctuation">.</span>hostname<span class="token punctuation">;</span>
<span class="token keyword">var</span> url <span class="token operator">=</span> location<span class="token punctuation">.</span>href<span class="token punctuation">;</span>

<span class="token comment">// use with</span>
<span class="token keyword">with</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> qs <span class="token operator">=</span> search<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> hostName <span class="token operator">=</span> hostname<span class="token punctuation">;</span>
  <span class="token keyword">var</span> url <span class="token operator">=</span> href<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用 with 语句关联了 location 对象。这意味着在 with 语句的代码块 内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询 location 对象中是否有同名的属性。如果发现了同名属性，则以 location 对象属性的值作为变量的值。</p> <p>严格模式下不允许使用 with 语句，否则将视为语法错误。</p> <blockquote><p>提示：由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。</p></blockquote> <h4 id="switch-语句"><a href="#switch-语句" class="header-anchor">#</a> switch 语句</h4> <p>switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。</p> <h3 id="_3-7-函数"><a href="#_3-7-函数" class="header-anchor">#</a> 3.7. 函数</h3> <p>严格模式对函数有一些限制:</p> <ul><li>不能把函数命名为 eval 或 arguments;</li> <li>不能把参数命名为 eval 或 arguments;</li> <li>不能出现两个命名参数同名的情况。</li></ul> <p>如果发生以上情况，就会导致语法错误，代码无法执行。</p> <h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <p>通过类数组对象 arguments 访问函数参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">doAdd</span><span class="token punctuation">(</span><span class="token parameter">num1<span class="token punctuation">,</span> num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>每次执行这个 doAdd()函数都会重写第二个参数，将第二个参数的值修改为 10。因为 arguments 对象中的值会自动反映到对应的命名参数，所以修改 arguments[1]，也就修改了 num2，结果它们的 值都会变成 10。不过，这并不是说读取这两个值会访问相同的内存空间;它们的内存空间是独立的，但 它们的值会同步。另外还要记住，如果只传入了一个参数，那么为 arguments[1]设置的值不会反应到 命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名 参数的个数决定的。</p> <p>关于参数还要记住最后一点:没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了 变量但又没有初始化一样。例如，如果只给 doAdd()函数传递了一个参数，则 num2 中就会保存 undefined 值。</p> <p>严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无 效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写 arguments 的值会导致语法错误(代码将不会执行)。</p> <blockquote><p>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</p></blockquote> <h4 id="没有重载"><a href="#没有重载" class="header-anchor">#</a> 没有重载</h4> <p>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言(如 Java)中，可以为一个函数 编写两个定义，只要这两个定义的签名(接受的参数的类型和数量)不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。</p> <p>如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_3-基本概念" title="3. 基本概念">3. 基本概念</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-1-语法" title="3.1 语法">3.1 语法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-2-关键字和保留字" title="3.2 关键字和保留字">3.2 关键字和保留字</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-4-数据类型" title="3.4 数据类型">3.4 数据类型</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-5-操作符" title="3.5 操作符">3.5 操作符</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-6-语句" title="3.6 语句">3.6 语句</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3-7-函数" title="3.7. 函数">3.7. 函数</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://github.com/bangkk" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-fdbf4940><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-fdbf4940></path></svg>
          
        </a></li><li class="contact-item" data-v-fdbf4940><a href="mailto:bangkk0812@gmail.com" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-fdbf4940><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-fdbf4940></path><polyline points="22,6 12,13 2,6" data-v-fdbf4940></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="/blog/2020/07/18/js%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/.html" class="nav-link" data-v-fdbf4940>BangKk © 2020</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.09de7167.js" defer></script><script src="/blog/assets/js/7.81338775.js" defer></script><script src="/blog/assets/js/3.91e53e24.js" defer></script><script src="/blog/assets/js/10.a2a5e182.js" defer></script>
  </body>
</html>
